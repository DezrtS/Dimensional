#pragma kernel CSMain

struct Triangle
{
    float3 v0;
    float3 v1;
    float3 v2;
    float2 uv0;
    float2 uv1;
    float2 uv2;
    float3 normal;
    float  area;
};

struct GrassVertex
{
    float3 position;
    float3 normal;
    float  height01; // 0 = base, 1 = tip
    float2 uv;
};

struct GrassMask
{
    float3 position;
    float3 size;
    float rotation;
};

Texture2D<float> _MaskTexture0;
Texture2D<float> _MaskTexture1;
Texture2D<float> _MaskTexture2;
Texture2D<float> _MaskTexture3;
Texture2D<float> _MaskTexture4;
Texture2D<float> _MaskTexture5;

StructuredBuffer<GrassMask> _Masks;

StructuredBuffer<Triangle> _Triangles;

RWStructuredBuffer<GrassVertex> _Vertices;
RWStructuredBuffer<uint>        _Indices;

RWStructuredBuffer<uint> _VertexCounter;
RWStructuredBuffer<uint> _IndexCounter;

uint   _TriangleCount;

int   _BladesPerSquareUnit;
int   _BladeSegments;
float _BladeHeight;
float _BladeWidth;
float _WidthTaper;
float _CurveFactor;

uint _MaskCount;

uint AllocateVertices(uint count)
{
    uint old;
    InterlockedAdd(_VertexCounter[0], count, old);
    return old;
}

uint AllocateIndices(uint count)
{
    uint old;
    InterlockedAdd(_IndexCounter[0], count, old);
    return old;
}

float2 RemapToUV(float3 worldPos, GrassMask mask)
{
    float3 local = (worldPos - mask.position) / mask.size;

    float s = sin(-mask.rotation);
    float c = cos(-mask.rotation);

    float2 rotated = float2(
        local.x * c - local.z * s,
        local.x * s + local.z * c
    );

    return rotated * 0.5 + 0.5;
}

#define MAX_MASKS 4
SamplerState sampler_LinearClamp;

float SampleMask(uint index, float2 uv)
{
    if (index == 0) return _MaskTexture0.SampleLevel(sampler_LinearClamp, uv, 0);
    if (index == 1) return _MaskTexture1.SampleLevel(sampler_LinearClamp, uv, 0);
    if (index == 2) return _MaskTexture2.SampleLevel(sampler_LinearClamp, uv, 0);
    if (index == 3) return _MaskTexture3.SampleLevel(sampler_LinearClamp, uv, 0);
    if (index == 4) return _MaskTexture4.SampleLevel(sampler_LinearClamp, uv, 0);
    if (index == 5) return _MaskTexture5.SampleLevel(sampler_LinearClamp, uv, 0);
    return 0.0f;
}

[numthreads(64, 1, 1)]
void CSMain(uint id : SV_DispatchThreadID)
{
    if (id >= _TriangleCount)
        return;

    Triangle tri = _Triangles[id];

    uint bladeCount = (uint)(tri.area * _BladesPerSquareUnit);

    for (uint i = 0; i < bladeCount; i++)
    {
        // === RANDOM BARYCENTRIC POINT ===
        float2 r = float2(
            frac(sin(dot(float2(id, i), float2(12.9898,78.233))) * 43758.5453),
            frac(sin(dot(float2(i, id), float2(39.3467,11.135))) * 96321.517)
        );

        if (r.x + r.y > 1.0)
            r = 1.0 - r;

        float3 bladePos =
            tri.v0 +
            r.x * (tri.v1 - tri.v0) +
            r.y * (tri.v2 - tri.v0);

        float2 bladeUV = tri.uv0 + r.x * (tri.uv1 - tri.uv0) + r.y * (tri.uv2 - tri.uv0);

        // === Mask
        bool skip = false;
        for (uint j = 0; j < _MaskCount; j++)
        {
            if (j >= MAX_MASKS) continue;
            GrassMask mask = _Masks[j];
            float2 uv = RemapToUV(bladePos, mask);
            
            if (uv.x >= 0 && uv.x <= 1 && uv.y >= 0 && uv.y <= 1)
            {
                float maskValue = SampleMask(j, uv);
                if (maskValue > 0.5f)
                {
                    skip = true;
                    break;
                }
            }
        }

        if (skip) continue;
        float3 up = normalize(tri.normal);

        // === RANDOM ROTATION ===
        float rand = frac(sin(dot(float2(i, id), float2(91.345, 12.678))) * 47453.5453);
        float angle = rand * 6.28318530718;

        float3 right = abs(up.y) > 0.99
            ? float3(1,0,0)
            : normalize(cross(float3(0,1,0), up));

        float3 forward = normalize(cross(right, up));

        float s = sin(angle);
        float c = cos(angle);

        float3 rRight   =  right * c + forward * s;
        float3 rForward = -right * s + forward * c;

        // === SEGMENTS ===
        float segmentHeight = _BladeHeight / _BladeSegments;
        
        float3 currPos = bladePos;
        
        // Base
        uint baseVertexIndex = AllocateVertices(2 + (_BladeSegments - 1) * 2 + 1);
        uint baseIndicesIndex = AllocateIndices(2 + (_BladeSegments - 1) * 6 + 1);
        
        GrassVertex baseV0, baseV1;
        float width = _BladeWidth * pow(1.0, _WidthTaper);
        baseV0.position = currPos - rRight * width * 0.5;
        baseV1.position = currPos + rRight * width * 0.5;
        baseV0.normal = baseV1.normal = up;
        baseV0.height01 = baseV1.height01 = 0;
        baseV0.uv = baseV1.uv = bladeUV;

        _Vertices[baseVertexIndex + 0] = baseV0;
        _Vertices[baseVertexIndex + 1] = baseV1;
        
        _Indices[baseIndicesIndex + 0] = baseVertexIndex + 0;
        _Indices[baseIndicesIndex + 1] = baseVertexIndex + 1;
        

        for (int seg = 1; seg < _BladeSegments; seg++)
        {
            float t = (float)seg / _BladeSegments;
            float bend = t * t * _CurveFactor;

            float3 currDir = normalize(
                up * cos(bend) +
                rForward * sin(bend)
            );

            currPos += currDir * segmentHeight;
            float w0 = _BladeWidth * pow(abs(1.0 - t), _WidthTaper);

            // === VERTICES ===
            GrassVertex v0, v1;
            v0.position = currPos - rRight * w0 * 0.5;
            v1.position = currPos + rRight * w0 * 0.5;
            v0.normal = v1.normal = up;
            v0.height01 = v1.height01 = t;
            v0.uv = v1.uv = bladeUV;

            uint vertexIndex = (seg - 1) * 2 + baseVertexIndex + 2;
            uint indicesIndex = (seg - 1) * 6 + baseIndicesIndex + 2;
            
            _Vertices[vertexIndex + 0] = v0;
            _Vertices[vertexIndex + 1] = v1;
            
            _Indices[indicesIndex + 0] = vertexIndex + 0;
            _Indices[indicesIndex + 1] = vertexIndex - 1;
            _Indices[indicesIndex + 2] = vertexIndex + 0;
            _Indices[indicesIndex + 3] = vertexIndex + 1;
            _Indices[indicesIndex + 4] = vertexIndex + 0;
            _Indices[indicesIndex + 5] = vertexIndex + 1;
        }
        
        float3 currDir = normalize(
            up * cos(_CurveFactor) +
            rForward * sin(_CurveFactor)
        );

        currPos += currDir * segmentHeight;

        // Tip
        GrassVertex tipV;
        tipV.position = currPos;
        tipV.normal = up;
        tipV.height01 = 1;
        tipV.uv = bladeUV;

        uint vertexIndex = (_BladeSegments - 1) * 2 + baseVertexIndex + 2;
        uint indicesIndex = (_BladeSegments - 1) * 6 + baseIndicesIndex + 2;

        _Vertices[vertexIndex + 0] = tipV;
        _Indices[indicesIndex + 0] = vertexIndex + 0;
    }
}
