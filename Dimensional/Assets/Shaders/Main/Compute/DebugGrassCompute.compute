#pragma kernel CSMain


struct Triangle
{
    float3 v0;
    float3 v1;
    float3 v2;
    float3 normal;
    float  area;
};

struct GrassVertex
{
    float3 position;
    float3 normal;
    float  height01; // 0 = base, 1 = tip
};

StructuredBuffer<Triangle> _Triangles;

RWStructuredBuffer<GrassVertex> _Vertices;
RWStructuredBuffer<uint>        _Indices;

RWStructuredBuffer<uint> _VertexCounter;
RWStructuredBuffer<uint> _IndexCounter;

int   _TriangleCount;
int   _BladesPerSquareUnit;
int   _BladeSegments;

float _BladeHeight;
float _BladeWidth;
float _WidthTaper;
float _CurveFactor;

uint AllocateVertices(uint count)
{
    uint old;
    InterlockedAdd(_VertexCounter[0], count, old);
    return old;
}

uint AllocateIndices(uint count)
{
    uint old;
    InterlockedAdd(_IndexCounter[0], count, old);
    return old;
}


[numthreads(64, 1, 1)]
void CSMain(uint id : SV_DispatchThreadID)
{
    if (id >= _TriangleCount)
        return;

    Triangle tri = _Triangles[id];
    uint bladeCount = (uint)(tri.area * _BladesPerSquareUnit);

    for (uint i = 0; i < bladeCount; i++)
    {
        // === RANDOM BARYCENTRIC POINT ===
        float2 r = float2(
            frac(sin(dot(float2(id, i), float2(12.9898,78.233))) * 43758.5453),
            frac(sin(dot(float2(i, id), float2(39.3467,11.135))) * 96321.517)
        );

        if (r.x + r.y > 1.0)
            r = 1.0 - r;

        float3 bladePos =
            tri.v0 +
            r.x * (tri.v1 - tri.v0) +
            r.y * (tri.v2 - tri.v0);

        float3 up = normalize(tri.normal);

        // === RANDOM ROTATION ===
        float rand = frac(sin(dot(float2(i, id), float2(91.345, 12.678))) * 47453.5453);
        float angle = rand * 6.28318530718;

        float3 right = abs(up.y) > 0.99
            ? float3(1,0,0)
            : normalize(cross(float3(0,1,0), up));

        float3 forward = normalize(cross(right, up));

        float s = sin(angle);
        float c = cos(angle);

        float3 rRight   =  right * c + forward * s;

        // === SEGMENTS ===
        float segmentHeight = _BladeHeight / _BladeSegments;
        
        // Base
        GrassVertex baseV0, baseV1;
        baseV0.position = bladePos - rRight * 0.5;
        baseV1.position = bladePos + rRight * 0.5;
        baseV0.normal = baseV1.normal = up;
        baseV0.height01 = baseV1.height01 = 0;

        uint prevBaseIndex = AllocateVertices(3);
        _Vertices[prevBaseIndex + 0] = baseV0;
        _Vertices[prevBaseIndex + 1] = baseV1;
        uint prevIdx = AllocateIndices(3);
        _Indices[prevIdx + 0] = prevBaseIndex + 0;
        _Indices[prevIdx + 1] = prevBaseIndex + 1;
        
        // Tip
        GrassVertex tipV;
        tipV.position = bladePos + float3(0, segmentHeight, 0);
        tipV.normal = up;
        tipV.height01 = 1;

        _Vertices[prevBaseIndex + 2] = tipV;
        _Indices[prevIdx + 2] = prevBaseIndex + 2;
    }
}
